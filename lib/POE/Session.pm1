package POE::Session;

use strict;

sub OBJECT  () {  0 }
sub SESSION () {  1 }
sub KERNEL  () {  2 }
sub HEAP    () {  3 }
sub STATE   () {  4 }
sub SENDER  () {  5 }
# NFA keeps its state in 6.  unused in session so that args match up.
sub CALLER_FILE () { 7 }
sub CALLER_LINE () { 8 }
sub ARG0    () { 9 }
sub ARG1    () { 10 }
sub ARG2    () { 11 }
sub ARG3    () { 12 }
sub ARG4    () { 13 }
sub ARG5    () { 14 }
sub ARG6    () { 15 }
sub ARG7    () { 16 }
sub ARG8    () { 17 }
sub ARG9    () { 18 }

sub import {
  my $package = caller();
  no strict 'refs';
  *{ $package . '::OBJECT'  } = \&OBJECT;
  *{ $package . '::SESSION' } = \&SESSION;
  *{ $package . '::KERNEL'  } = \&KERNEL;
  *{ $package . '::HEAP'    } = \&HEAP;
  *{ $package . '::STATE'   } = \&STATE;
  *{ $package . '::SENDER'  } = \&SENDER;
  *{ $package . '::ARG0'    } = \&ARG0;
  *{ $package . '::ARG1'    } = \&ARG1;
  *{ $package . '::ARG2'    } = \&ARG2;
  *{ $package . '::ARG3'    } = \&ARG3;
  *{ $package . '::ARG4'    } = \&ARG4;
  *{ $package . '::ARG5'    } = \&ARG5;
  *{ $package . '::ARG6'    } = \&ARG6;
  *{ $package . '::ARG7'    } = \&ARG7;
  *{ $package . '::ARG8'    } = \&ARG8;
  *{ $package . '::ARG9'    } = \&ARG9;
  *{ $package . '::CALLER_FILE' } = \&CALLER_FILE;
  *{ $package . '::CALLER_LINE' } = \&CALLER_LINE;
}

sub create {
	my $class = shift;
	die "Uneven parameters list\n" unless @_ % 2 == 0;
	
	my $heap = {};
	my $states = {};
	my $args = [];
	# This line is different

	while (@_) {
		my $parameter = shift @_;
		my $value = shift @_;

		if ($parameter eq 'inline_states') {
			die unless ref $value eq 'HASH';
			$states = { %$states, %$value };
		}
		elsif ($parameter eq 'package_states' or $parameter eq 'object_states') {
			die unless ref $value eq 'ARRAY';
			die unless @$value % 2 == 0;
			while (@$value) {
				my $package = shift @$value;
				my $pstates = shift @$value;
				die unless ref $pstates eq 'ARRAY';
				foreach my $state (@$pstates) {
					$states->{$state} = sub {
						shift;
						return $package->$state(@_);
					};
				}
			}
		}
		elsif ($parameter eq 'heap') {
			$heap = $value;
		}
		elsif ($parameter eq 'args') {
			die unless ref $value eq 'ARRAY';
			$args = $value;
		}
		else {
			die "Unknown parameter: $parameter\n";
		}
	}

	my $self = bless {
		states => $states,
		heap => $heap,
		kernel	=> $POE::Kernel::poe_kernel, # Dangerous?
	}, (ref $class || $class);

	$POE::Kernel::poe_kernel->session_alloc( $self, @$args );

	return $self;
}

# Exactly the same
sub ID {
	$POE::Kernel::poe_kernel->ID_session_to_id(shift);
}

# Exactly the same
sub register_state {
	my $self = shift;
	my $event = shift;
	my $ref = shift;

	die unless $event;

	if (not $ref) {
		delete( $self->{states}->{$event} );
	}
	elsif (ref $ref eq 'CODE') {
		$self->{states}->{$event} = $ref;
	}
	else {
		my $method = shift;
		$method = $event unless( length $method );
		$self->{states}->{$event} = sub { shift; $ref->$method(@_); };
	}
}

# POE doesn't use the kernel in pass, otherwise the same
sub _invoke_state {
	my $self = shift;
	my ($from, $state, $etc) = @_;

	if (exists $self->{states}->{$state}) {
		$self->{states}->{$state}->(
			undef,	# OBJECT
			$self,	# SESSION
			$POE::Kernel::poe_kernel,	# KERNEL
			$self->{heap},	# HEAP
			$state,	# STATE
			$from,	# SENDER
			undef,	# NFA STATE (Not used)
			undef,	# CALLER_FILE
			undef,	# CALLER_LINE
			@$etc	# ARGS
		);
	}
	else {
	}
}

1;
